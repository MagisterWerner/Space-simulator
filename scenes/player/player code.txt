Absolutely! Here's the complete refactored player code, ready to be pasted into your Godot project:

```gdscript
extends RigidBody2D
class_name Player

var alive = true
@export var health_regeneration = 1
@export var MAX_HEALTH = 100 # (int, 300)
@export var speed = 2


@export var move_right_action := "p1_right"
@export var move_left_action := "p1_left"
@export var move_down_action := "p1_down"
@export var move_up_action := "p1_up"
@export var primary_action := "p1_primary"
@export var secondary_action := "p1_secondary"

var laser_attack_time = 0
var laser_cooldown_time = 250
var missile_attack_time = 0
var missile_cooldown_time = 1000
var AlternateLaser = 0

var collision_force : Vector2 = Vector2.ZERO
var previous_linear_velocity : Vector2 = Vector2.ZERO

signal player_stats_changed

@export var health: int = 100: set = _set_health
signal health_updated(new_value)


# Cached node references
var l_node: Node2D
var r_node: Node2D
var main_thruster: Node2D
var l_rear_thruster: Node2D
var r_rear_thruster: Node2D
var l_front_thruster: Node2D
var r_front_thruster: Node2D
var lw_node: Node2D
var rw_node: Node2D


# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	Globals.set("node_player", self)

	# Cache node references
	l_node = $L
	r_node = $R
	main_thruster = $MainThruster
	l_rear_thruster = $L/RearThruster
	r_rear_thruster = $R/RearThruster
	l_front_thruster = $L/FrontThruster
	r_front_thruster = $R/FrontThruster
	lw_node = $LW
	rw_node = $RW


func _set_health(new_value:int) -> void:
	health = clamp(new_value, 0, MAX_HEALTH)
	emit_signal("health_updated", health)
	

func _integrate_forces(state : PhysicsDirectBodyState2D)->void:
	collision_force = Vector2.ZERO

	if state.get_contact_count() > 0:
		var dv : Vector2 = state.linear_velocity - previous_linear_velocity
		collision_force = dv / (state.inverse_mass * state.step)

	previous_linear_velocity = state.linear_velocity


func _process(delta):
	# Regenerates health
	var new_health = min(health + health_regeneration * delta, MAX_HEALTH)
	if new_health != health:
		health = new_health
		emit_signal("player_stats_changed", self)
	elif health == MAX_HEALTH:
		emit_signal("player_stats_changed", self)
	


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _physics_process(_delta: float) -> void:
	if alive:
		update_actor_direction()
	else:
		visible = false
		get_tree().create_timer(1.0).connect("timeout", Callable(self, "_PlayerDeath"))


func _PlayerDeath():
	get_tree().change_scene_to_file("res://UI/Title.tscn")


func _damage(amount):
	health -= amount
	if health > 0:
		print("Your ship took ", amount, " damage and is now at ", health, "!")
	else:
		health = 0
		alive = false
		print("Your ship took ", amount, " damage and was detroyed!")
		explode()


func _on_Player_body_entered(body: Node) -> void:
	if alive:
		if is_instance_valid(body) and body.is_in_group("ASTEROIDS") or body.is_in_group("ENEMIES"):
			var dmg_amount = floor( ( (abs(collision_force.x)) + (abs(collision_force.y)) ) / 1000 )
			var crit = false
			if dmg_amount > 1:
				crit = true if randi() % 100 < 10 else false
				if crit:
					dmg_amount *= 2
				_damage(dmg_amount)


func update_actor_direction() -> void:
	# Thruster control (simplified and using cached nodes)
	if Input.get_action_strength(move_right_action) > 0:
		apply_impulse(Vector2(0, -speed * 0.5).rotated(rotation), l_node.position.rotated(rotation))
		l_rear_thruster.set_deferred("emitting", true)
	else:
		l_rear_thruster.set_deferred("emitting", false)

	if Input.get_action_strength(move_left_action) > 0:
		apply_impulse(Vector2(0, -speed * 0.5).rotated(rotation), r_node.position.rotated(rotation))
		r_rear_thruster.set_deferred("emitting", true)
	else:
		r_rear_thruster.set_deferred("emitting", false)

	if Input.get_action_strength(move_up_action) > 0:
		apply_central_impulse(Vector2(0, -speed * 8).rotated(rotation))
		main_thruster.set_deferred("emitting", true)
	else:
		main_thruster.set_deferred("emitting", false)

	if Input.get_action_strength(move_down_action) > 0:
		apply_central_impulse(Vector2(0, speed * 2).rotated(rotation))

		if Input.get_action_strength(move_right_action) > 0 and Input.get_action_strength(move_left_action) == 0:
			apply_impulse(Vector2(0, speed * 0.5).rotated(rotation), r_node.position.rotated(rotation))
			r_front_thruster.set_deferred("emitting", true)
			l_front_thruster.set_deferred("emitting", false)
		elif Input.get_action_strength(move_left_action) > 0 and Input.get_action_strength(move_right_action) == 0:
			apply_impulse(Vector2(0, speed * 0.5).rotated(rotation), l_node.position.rotated(rotation))
			l_front_thruster.set_deferred("emitting", true)
			r_front_thruster.set_deferred("emitting", false)
		else:
			l_front_thruster.set_deferred("emitting", true)
			r_front_thruster.set_deferred("emitting", true)
	else:
		l_front_thruster.set_deferred("emitting", false)
		r_front_thruster.set_deferred("emitting", false)

 
 
	if Input.get_action_strength(primary_action) :
		# Check if player can attack
		var now = Time.get_ticks_msec()
		if now >= laser_attack_time:
			fire_laser()
			# Add cooldown time to current time
			laser_attack_time = now + laser_cooldown_time

	if Input.get_action_strength(secondary_action) :
		# Check if player can attack
		var now = Time.get_ticks_msec()
		if now >= missile_attack_time:
			fire_missile()
			# Add cooldown time to current time
			missile_attack_time = now + missile_cooldown_time


func fire_laser():
	if AlternateLaser == 0:
		var rw = Globals.scene_laser.instantiate()
		rw.transform = rw_node.global_transform
		ObjectRegistry._projectiles.add_child(rw)
		AlternateLaser = 1

	elif AlternateLaser == 1:
		var lw = Globals.scene_laser.instantiate()
		lw.transform = lw_node.global_transform
		ObjectRegistry._projectiles.add_child(lw)
		AlternateLaser = 0
	


func fire_missile():
	var missile = Globals.scene_missile.instantiate()
	missile.transform = global_transform
	ObjectRegistry
